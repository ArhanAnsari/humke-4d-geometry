<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>MathBox - 4D Cartesian w/ projection</title>
  <script src="../../build/mathbox-bundle.js"></script>
  <link rel="stylesheet" href="../../build/mathbox.css">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1">
</head>
<body>
  <script>
    mathbox = mathBox({
      plugins: ['core', 'controls', 'cursor'],
      controls: {
        klass: THREE.OrbitControls
      },
    });
    three = mathbox.three;

    three.camera.position.set(2.3, 1, 2);
    three.renderer.setClearColor(new THREE.Color(0xFFFFFF), 1.0);

    var rot_matrix = [
        1, 0, 0, .577,
        0, 1, 0, .577,
        0, 0, 1, .577,
        0, 0, 0, 1,
      ]

    view = mathbox.transform4({
      matrix: rot_matrix,
      id:'transform',
    }).cartesian4({
      range: [[-1, 1], [-1, 1], [-1, 1], [-1, 1]],
      scale: [1, 1, 1, 1],
    });

    view.axis({
      axis: 1,
    });
    view.grid({
      axes: [1, 3],
      width: 4,
    });

    view.axis({
      axis: 2,
    });

    view.axis({
      axis: 3,
    });

    view.axis({
      axis: 4,
    });

    function DrawCube(size,step){
      var arr = []
      for(var x=0;x<=1;x+=step){
        for(var y=0;y<=1;y+=step){
          for(var z=0;z<=1;z+=step){
            //for(var w=-1;w<=1;w++){
              arr.push([x*size-size/2,y*size-size/2,z*size-size/2])
            //}

          }
        }
      }
      return arr;
    }

    var cube = DrawCube(1,1);
    var pointsArray = [];
    var edges = [];

    for(var i=0;i<cube.length;i++){
      var p1 = [cube[i][0],cube[i][1],cube[i][2],-0.5]
      var p2 = [cube[i][0],cube[i][1],cube[i][2],0.5]
      pointsArray.push(p1)
      pointsArray.push(p2)
    }

    for(var i=0;i<pointsArray.length;i++){
      var p = pointsArray[i];
      for(var j=0;j<pointsArray.length;j++){
        var p2 = pointsArray[j];
        // To connect an edge, p and p2 must differ by only one coordinate 
        var diff = 0; 
        for(var k=0;k<p.length;k++){
          if(p[k] != p2[k]) diff++;
        }
        if(diff == 1){
          edges.push([p,p2])
        }
      }
    }

    view.array({
      id:'colors',
      width: pointsArray.length,
      expr: function (emit,i, time) {
        var p = pointsArray[i];
        var x = p[0];
        var y = p[1];
        var z = p[2];
        var w = p[3]-0.5;

        emit(w*2, 0, 0, 1);
      },
      channels: 4,
    })

    view.array({
      id:'edge_colors',
      width: edges.length,
      expr: function (emit,i, time) {
        var p1 = edges[i][0];
        var p2 = edges[i][1];
        var w1 = p1[3]-0.5;
        var w2 = p2[3]-0.5;
        emit((w1+w2), 0, 0, 1);
        
      },
      channels: 4,
    })

    function project(num,w){
      return num * (1 / (-1 - w));
    }

    function rotate(point,t){
      var x = point[0];
      var y = point[1];
      var z = point[2];
      var w = point[3];

      var cos = Math.cos(t);
      var sin = Math.sin(t);

      // Rotate along xy
      // var new_x = cos * x - sin * y;
      // var new_y = sin * x + cos * y;
      // x = new_x;
      // y = new_y;

      // Rotate along wz
      var new_w = cos * w - sin * z;
      var new_z = sin * w + cos * z;
      w = new_w;
      z = new_z;

      return [x,y,z,w];
    }

    // Native 4D
    view.array({
      width: pointsArray.length,
      expr: function (emit,i, time) {
        var p = rotate(pointsArray[i],time);
        var x = p[0];
        var y = p[1];
        var z = p[2];
        var w = p[3];

        // Project using stereographic projection according to 3:30 at https://www.youtube.com/watch?v=iGO12Z5Lw8s 
        x = project(x,w);
        y = project(y,w);
        z = project(z,w);

        emit(x, y, z, 0);
      },
      channels: 4,
    });

    view.point({
      colors: '#colors',
      size: 40,
    });

    // Draw the edges 
    view.array({
      width: edges.length,
      expr: function(emit,i,time){
        var p1 = rotate(edges[i][0],time);
        var p2 = rotate(edges[i][1],time);
        var w1 = p1[3];
        var w2 = p2[3];

        var x1 = project(p1[0],w1); var x2 = project(p2[0],w2);
        var y1 = project(p1[1],w1); var y2 = project(p2[1],w2);
        var z1 = project(p1[2],w1); var z2 = project(p2[2],w2);

        emit(x1,y1,z1,0);
        emit(x2,y2,z2,0);
      },
      channels:4,
      items:2,
    })
    view.vector({
      colors: '#edge_colors',
      width:10,
      start:false
    })

    var count = 0;

    setInterval(function(){
      count += 0.01;
      // rot_matrix[3] = Math.sin(count);
      // rot_matrix[7] = rot_matrix[3];
      // rot_matrix[11] = rot_matrix[3];
      // rot_matrix[0] = Math.cos(count);
      // rot_matrix[1] = Math.sin(count) * -1;
      // rot_matrix[4] = Math.sin(count);
      // rot_matrix[5] = Math.cos(count);
      // rot_matrix[10] = Math.cos(count);
      // rot_matrix[11] = Math.sin(count) * -1;
      // rot_matrix[14] = Math.sin(count);
      // rot_matrix[15] = Math.cos(count);

      mathbox.select("#transform").set("matrix",rot_matrix)
    },1000/60)

  </script>
</body>
</html>
