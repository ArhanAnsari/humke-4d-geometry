<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>MathBox - 4D Cartesian w/ projection</title>
  <script src="../../build/mathbox-bundle.js"></script>
  <link rel="stylesheet" href="../../build/mathbox.css">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1">
</head>
<body>
  <script>
    mathbox = mathBox({
      plugins: ['core', 'controls', 'cursor'],
      controls: {
        klass: THREE.OrbitControls
      },
    });
    three = mathbox.three;

    three.camera.position.set(2.3, 1, 2);
    three.renderer.setClearColor(new THREE.Color(0xFFFFFF), 1.0);

    var rot_matrix = [
        1, 0, 0, .577,
        0, 1, 0, .577,
        0, 0, 1, .577,
        0, 0, 0, 1,
      ]

    view = mathbox.transform4({
      matrix: rot_matrix,
      id:'transform',
    }).cartesian4({
      range: [[-1, 1], [-1, 1], [-1, 1], [-1, 1]],
      scale: [1, 1, 1, 1],
    });

    view.axis({
      axis: 1,
    });
    view.grid({
      axes: [1, 3],
      width: 4,
    });

    view.axis({
      axis: 2,
    });

    view.axis({
      axis: 3,
    });

    view.axis({
      axis: 4,
    });

    function DrawCube(size,step){
      var arr = []
      for(var x=0;x<=1;x+=step){
        for(var y=0;y<=1;y+=step){
          for(var z=0;z<=1;z+=step){
            //for(var w=-1;w<=1;w++){
              arr.push([x*size,y*size,z*size])
            //}

          }
        }
      }
      return arr;
    }

    var cube = DrawCube(1,1);
    var pointsArray = [];
    var edges = [];

    


    for(var i=0;i<cube.length;i++){
      var p1 = [cube[i][0],cube[i][1],cube[i][2],0]
      var p2 = [cube[i][0],cube[i][1],cube[i][2],1]
      pointsArray.push(p1)
      pointsArray.push(p2)
    }

    for(var i=0;i<pointsArray.length;i++){
      var p = pointsArray[i];
      for(var j=0;j<pointsArray.length;j++){
        var p2 = pointsArray[j];
        // To connect an edge, p and p2 must differ by only one coordinate 
        var diff = 0; 
        for(var k=0;k<p.length;k++){
          if(p[k] != p2[k]) diff++;
        }
        if(diff == 1){
          edges.push([p,p2])
        }
      }
    }

    view.array({
      id:'colors',
      width: pointsArray.length,
      expr: function (emit,i, time) {
        var p = pointsArray[i];
        var x = p[0];
        var y = p[1];
        var z = p[2];
        var w = p[3];

        emit(w, 0, 0, 1);
      },
      channels: 4,
    })

    view.array({
      id:'edge_colors',
      width: edges.length,
      expr: function (emit,i, time) {
        var p1 = edges[i][0];
        var p2 = edges[i][1];
        var w1 = p1[3];
        var w2 = p2[3];
        emit((w1+w2)/2, 0, 0, 1);
        
      },
      channels: 4,
    })

    // Native 4D
    view.array({
      width: pointsArray.length,
      expr: function (emit,i, time) {
        var p = pointsArray[i];
        var x = p[0];
        var y = p[1];
        var z = p[2];
        var w = p[3];

        emit(x, y, z, w);
      },
      channels: 4,
    });

    view.point({
      colors: '#colors',
      size: 40,
    });

    // Draw the edges 
    view.array({
      width: edges.length,
      expr: function(emit,i,time){
        var p1 = edges[i][0];
        var p2 = edges[i][1];
        emit(p1[0],p1[1],p1[2],p1[3]);
        emit(p2[0],p2[1],p2[2],p2[3]);
      },
      channels:4,
      items:2,
    })
    view.vector({
      colors: '#edge_colors',
      width:10,
      start:false
    })

    var count = 0;

    setInterval(function(){
      count += 0.01;
      rot_matrix[3] = Math.sin(count);
      rot_matrix[7] = rot_matrix[3];
      rot_matrix[11] = rot_matrix[3];

      mathbox.select("#transform").set("matrix",rot_matrix)
    },1000/60)

  </script>
</body>
</html>
