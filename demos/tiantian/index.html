<!DOCTYPE html>
<html>
<head>
    <title>2D Cartesian Shader</title>
    <link rel="icon", href="favicon.png" />
    <link rel="stylesheet" type="text/css" href="normalize.css" />
</head>
<body>
    <section id="viewer"></section>
    <script id="fragmentShader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision mediump float;
        #endif

        #define PI 3.14159265359

        uniform vec2 u_resolution;

        void main() {
            vec2 st = gl_FragCoord.xy/u_resolution;

            vec4 color = vec4(1.0, 1.0, 1.0, 0.0);
            if (st.y > st.x) {
                color.r = 0.0;
                color.a = 1.0;
            }
            gl_FragColor = color;
        }
    </script>
    <script src="three.min.js"></script>
    <script type="text/javascript">
        var container, scene, camera, renderer;
        var width = window.innerWidth, height = window.innerHeight;
        var graphWidth, graphHeight;

        init();
        animate();

        function toScreenPosition(obj)
        {
            var vector = new THREE.Vector3();

            var widthHalf = 0.5*window.innerWidth;
            var heightHalf = 0.5*window.innerHeight;

            obj.updateMatrixWorld();
            vector.setFromMatrixPosition(obj.matrixWorld);
            vector.project(camera);

            vector.x = ( vector.x * widthHalf ) + widthHalf;
            vector.y = - ( vector.y * heightHalf ) + heightHalf;

            return { 
                x: vector.x,
                y: vector.y
            };

        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            var viewAngle = 75, aspect = width / height, near = 1, far = 1000;
            camera = new THREE.PerspectiveCamera(viewAngle, aspect, near, far);
            camera.position.set(0, 0, 0);

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);

            container = document.querySelector("#viewer");
            container.appendChild(renderer.domElement);

            var equation = "x^2 + y^2 = 9";
            var graph = initCartesian(equation);
            graph.position.z = -aspect*11;
            scene.add(graph);

            var size = 20, divisions = 20, colorCenterLine = 0x444444, colorGrid = 0xd0d0d0;
            var grid = new THREE.GridHelper(size, divisions, colorCenterLine, colorGrid);
            grid.rotation.x = Math.PI/2;
            grid.position.z = -aspect*11;
            scene.add(grid);

            var g1 = grid.clone();
           
            g1.position.x += 10;
            g1.position.y -= 10;
            console.log(toScreenPosition(g1));

            var g2 = grid.clone();
            
            g2.position.x -= 10;
            g2.position.y += 10;
            console.log(toScreenPosition(g2));

            graphWidth = toScreenPosition(g1).x - toScreenPosition(g2).x;
            graphHeight = toScreenPosition(g1).y - toScreenPosition(g2).y;

            console.log(graphWidth, graphHeight);

            update();
            window.addEventListener('resize', update, false);
        }

        function update() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            uniforms.u_resolution.value.x = graphWidth;
            uniforms.u_resolution.value.y = graphHeight;
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function initCartesian(eq) {
            var equation = eq;
            var geometry = new THREE.PlaneBufferGeometry(20, 20);
            uniforms = {
                u_resolution: {type: "v2", value: new THREE.Vector2(graphWidth, graphHeight)}
            };
            var material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                fragmentShader: document.querySelector("#fragmentShader").textContent
            });
            var graph = new THREE.Mesh(geometry, material);

            return graph;
        }
    </script>
</body>
</html>