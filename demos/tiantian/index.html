<!DOCTYPE html>
<html>
<head>
    <title>2D Cartesian Shader</title>
    <link rel="icon", href="favicon.png" />
    <link rel="stylesheet" type="text/css" href="normalize.css" />
</head>
<body>
    <section id="viewer"></section>
    <script id="fragmentShader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision mediump float;
        #endif

        #define PI 3.14159265359

        uniform vec2 u_resolution;
        varying vec4 vertexPosition;

        float eq(float x,float y){
            return pow(x,2.0) + pow(y,2.0) - 10.0;
        }

        void main() {
            vec4 color = vec4(0.0);
            float val = eq(vertexPosition.x,vertexPosition.y);
            float thickness = 0.5;
            //if(val < 0.0) color.r = 1.0; else discard;
            // if(val < 0.0) color.r = 1.0; else discard;
            if(val <= thickness && val >= -thickness) color.r = 1.0; else discard;

            gl_FragColor = color;
        }
    </script>
    <script id="vertexShader" type="x-shader/x-vertex">
            varying vec4 vertexPosition;
            void main() {
                vertexPosition = modelMatrix * vec4(position,1.0);

                gl_Position = projectionMatrix *
                              modelViewMatrix *
                              vec4(position,1.0); 
            }   
    </script>
    <script src="three.min.js"></script>
    <script type="text/javascript">
        var container, scene, camera, renderer;
        var width = window.innerWidth, height = window.innerHeight;
        var graphWidth, graphHeight;

        init();
        animate();

        function toScreenPosition(obj)
        {
            var vector = new THREE.Vector3();

            var widthHalf = 0.5*window.innerWidth;
            var heightHalf = 0.5*window.innerHeight;

            obj.updateMatrixWorld();
            vector.setFromMatrixPosition(obj.matrixWorld);
            vector.project(camera);

            vector.x = ( vector.x * widthHalf ) + widthHalf;
            vector.y = - ( vector.y * heightHalf ) + heightHalf;

            return { 
                x: vector.x,
                y: vector.y
            };

        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            var viewAngle = 75, aspect = width / height, near = 1, far = 1000;
            camera = new THREE.PerspectiveCamera(viewAngle, aspect, near, far);
            camera.position.set(0, 0, 0);

            renderer = new THREE.WebGLRenderer();
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);

            container = document.querySelector("#viewer");
            container.appendChild(renderer.domElement);

            var equation = "x^2 + y^2 = 9";
            var graph = initCartesian(equation);
            graph.position.z = -15+ 0.1;
            scene.add(graph);

            var size = 20, divisions = 20, colorCenterLine = 0x444444, colorGrid = 0xd0d0d0;
            var grid = new THREE.GridHelper(size, divisions, colorCenterLine, colorGrid);
            grid.rotation.x = Math.PI/2;
            grid.position.z = -15;
            scene.add(grid);

            var g1 = grid.clone();
           
            g1.position.x += 10;
            g1.position.y -= 10;
            console.log(toScreenPosition(g1));

            var g2 = grid.clone();
            
            g2.position.x -= 10;
            g2.position.y += 10;
            console.log(toScreenPosition(g2));

            graphWidth = toScreenPosition(g1).x - toScreenPosition(g2).x;
            graphHeight = toScreenPosition(g1).y - toScreenPosition(g2).y;

            console.log(graphWidth, graphHeight);

            update();
            window.addEventListener('resize', update, false);
        }

        function update() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            uniforms.u_resolution.value.x = graphWidth;
            uniforms.u_resolution.value.y = graphHeight;
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function initCartesian(eq) {
            var equation = eq;
            var geometry = new THREE.PlaneBufferGeometry(20, 20);
            uniforms = {
                u_resolution: {type: "v2", value: new THREE.Vector2(graphWidth, graphHeight)}
            };
            var material = new THREE.ShaderMaterial({
                uniforms: uniforms,
                fragmentShader: document.querySelector("#fragmentShader").textContent,
                vertexShader: document.querySelector("#vertexShader").textContent
            });
            var graph = new THREE.Mesh(geometry, material);
            graph.position.z = -15;

            return graph;
        }
    </script>
</body>
</html>