<!DOCTYPE html>
<html>
<head>
    <title>2D Cartesian Shader</title>
    <link rel="icon", href="favicon.png" />
</head>
<body>
    <section id="viewer"></section>

    <script src="../../src/lib/threejs/three.min.js"></script>
    <script src="../../src/lib/threejs/OrbitControls.js"></script>
    <script type="text/javascript">

        function calculate_intersections() {
          // calculate if triangles intersect
        }

        var container, scene, camera, renderer, controls;
        var width = window.innerWidth, height = window.innerHeight;
        var graphWidth, graphHeight;
        var light;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            var viewAngle = 75, aspect = width / height, near = 1, far = 1000;
            camera = new THREE.PerspectiveCamera(viewAngle, aspect, near, far);
            camera.position.set(0, 0, 5);

            renderer = new THREE.WebGLRenderer({antialias: true});
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);

            container = document.querySelector("#viewer");
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera,renderer.domElement);

            var lightSky = new THREE.HemisphereLight( 0xffffff, 0x080820, .7 );
        		scene.add( lightSky );
        		var lightGround = new THREE.HemisphereLight( 0xffffff, 0x080820, .4 );
            lightGround.position.y = -5;
        		lightGround.position.x = 2;
        		scene.add( lightGround );

            var cube_geometry = new THREE.BoxGeometry( 1, 1, 1 );
			      var material = new THREE.MeshPhongMaterial( {flatShading:true} );
			      var cube = new THREE.Mesh( cube_geometry, material );
            cube.scale.set(3,3,3);
			      scene.add( cube );

            // var points_data = [0.8143297795339766, 0.440590428598775, -0.9966778149797374, 0.8359636104069312,
            // 0.04038574084675473, 0.7631382697849891, 0.06488647783630208, 0.5470246612532295,
            // -0.1565304241669647, -0.8068455753911711, -0.6535871109492957, -0.8385764358924482,
            // 0.04584069274909863, 0.4445148496371831, 0.9610665477449694, 0.6454526024362561,
            // 0.1218762687611172, 0.3744402885198968, -0.7820816028696314, -0.4455011351457807,
            // 0.4624172658309502, -0.1530246242443329, 0.1151336972742656, -0.9479586388431104,
            // -0.3408434431448983, -0.555754094902197, -0.5590764978519422, -0.3987028481426675,
            // -0.9987734397861859, -0.3852024957399839, -0.09835071312110011, -0.9804424829598912,
            // 0.8837960566243119, -0.03969105802447637, 0.9123802677843536, 0.3751456852770836,
            // -0.926478310419692, 0.6790362016102636, 0.5614273236705245, -0.09098328937867961,
            // 0.8438482990896778, 0.5583483703046557, 0.1610475146780233, 0.7255701075546166,
            // 0.656784166262284, 0.5714694043355708, 0.6862663698254772, 0.07886445995314473,
            // -0.5250300108688232, -0.1793963892193478, 0.8848799689532072, 0.1776234453335623,
            // -0.6827634951870549, 0.7939339091944824, -0.3528022080220302, 0.4532847092051848,
            // 0.3560962382295134, 0.9094653110108015, -0.6165327854608491, -0.06652824121204037]
            //
            // var points = [];
            // for (var i=0;i<points_data.length;i+=4) {
            //   var new_point = new THREE.Vector4(points_data[i],points_data[i+1],points_data[i+2],points_data[i+3])
            //   points.push(new_point);
            // }

            // build tesseract
            var tesseract_geometry = new THREE.Geometry();

            geometry.vertices.push(
            	new THREE.Vector3( 1, 0, 0 ),
            	new THREE.Vector3( 0, 0, -1 ),
            	new THREE.Vector3( -1, 0, 0 ),
              new THREE.Vector3( 0, 1, -0.5)
            );

            geometry.faces.push( new THREE.Face3( 1, 3, 0 ));
            geometry.faces.push( new THREE.Face3( 2, 3, 1 ));
            geometry.faces.push( new THREE.Face3( 0, 3, 2 ));
            geometry.faces.push( new THREE.Face3( 1, 0, 2 ));

            var tesseract = new THREE.Mesh(tesseract_geometry, material);
            tesseract.scale.set(3,3,3);
            tesseract.position.x = -2;
            scene.add(tesseract);

            var intsection_points = [];
            for (var i=0;i<cube_geometry.faces.length;i++) {
              for (var j=0;j<tesseract_geometry.faces.length;j++) {

                calculate_intersections();

              }
            }

            update();
            window.addEventListener('resize', update, false);
        }

        function update() {
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>
